<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>GNU Octave: Special Functions</title>

<meta name="description" content="GNU Octave: Special Functions">
<meta name="keywords" content="GNU Octave: Special Functions">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Arithmetic.html#Arithmetic" rel="up" title="Arithmetic">
<link href="Rational-Approximations.html#Rational-Approximations" rel="next" title="Rational Approximations">
<link href="Utility-Functions.html#Utility-Functions" rel="prev" title="Utility Functions">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<a name="Special-Functions"></a>
<div class="header">
<p>
Next: <a href="Rational-Approximations.html#Rational-Approximations" accesskey="n" rel="next">Rational Approximations</a>, Previous: <a href="Utility-Functions.html#Utility-Functions" accesskey="p" rel="prev">Utility Functions</a>, Up: <a href="Arithmetic.html#Arithmetic" accesskey="u" rel="up">Arithmetic</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Special-Functions-1"></a>
<h3 class="section">17.6 Special Functions</h3>

<a name="XREFairy"></a><dl>
<dt><a name="index-airy"></a>Built-in Function: <em>[<var>a</var>, <var>ierr</var>] =</em> <strong>airy</strong> <em>(<var>k</var>, <var>z</var>, <var>opt</var>)</em></dt>
<dd><p>Compute Airy functions of the first and second kind, and their derivatives.
</p>
<div class="example">
<pre class="example"> K   Function   Scale factor (if &quot;opt&quot; is supplied)
---  --------   ---------------------------------------
 0   Ai (Z)     exp ((2/3) * Z * sqrt (Z))
 1   dAi(Z)/dZ  exp ((2/3) * Z * sqrt (Z))
 2   Bi (Z)     exp (-abs (real ((2/3) * Z * sqrt (Z))))
 3   dBi(Z)/dZ  exp (-abs (real ((2/3) * Z * sqrt (Z))))
</pre></div>

<p>The function call <code>airy (<var>z</var>)</code> is equivalent to
<code>airy (0, <var>z</var>)</code>.
</p>
<p>The result is the same size as <var>z</var>.
</p>
<p>If requested, <var>ierr</var> contains the following status information and
is the same size as the result.
</p>
<ol>
<li> Normal return.

</li><li> Input error, return <code>NaN</code>.

</li><li> Overflow, return <code>Inf</code>.

</li><li> Loss of significance by argument reduction results in less than half
 of machine accuracy.

</li><li> Complete loss of significance by argument reduction, return <code>NaN</code>.

</li><li> Error&mdash;no computation, algorithm termination condition not met,
return <code>NaN</code>.
</li></ol>
</dd></dl>


<a name="XREFbesselj"></a><dl>
<dt><a name="index-besselj"></a>Built-in Function: <em>[<var>j</var>, <var>ierr</var>] =</em> <strong>besselj</strong> <em>(<var>alpha</var>, <var>x</var>, <var>opt</var>)</em></dt>
<dt><a name="index-bessely"></a>Built-in Function: <em>[<var>y</var>, <var>ierr</var>] =</em> <strong>bessely</strong> <em>(<var>alpha</var>, <var>x</var>, <var>opt</var>)</em></dt>
<dt><a name="index-besseli"></a>Built-in Function: <em>[<var>i</var>, <var>ierr</var>] =</em> <strong>besseli</strong> <em>(<var>alpha</var>, <var>x</var>, <var>opt</var>)</em></dt>
<dt><a name="index-besselk"></a>Built-in Function: <em>[<var>k</var>, <var>ierr</var>] =</em> <strong>besselk</strong> <em>(<var>alpha</var>, <var>x</var>, <var>opt</var>)</em></dt>
<dt><a name="index-besselh"></a>Built-in Function: <em>[<var>h</var>, <var>ierr</var>] =</em> <strong>besselh</strong> <em>(<var>alpha</var>, <var>k</var>, <var>x</var>, <var>opt</var>)</em></dt>
<dd><p>Compute Bessel or Hankel functions of various kinds:
</p>
<dl compact="compact">
<dt><code>besselj</code></dt>
<dd><p>Bessel functions of the first kind.  If the argument <var>opt</var> is 1 or true,
the result is multiplied by <code>exp&nbsp;<span class="nolinebreak">(-abs</span>&nbsp;(imag&nbsp;(<var>x</var>)))</code><!-- /@w -->.
</p>
</dd>
<dt><code>bessely</code></dt>
<dd><p>Bessel functions of the second kind.  If the argument <var>opt</var> is 1 or true,
the result is multiplied by <code>exp (-abs (imag (<var>x</var>)))</code>.
</p>
</dd>
<dt><code>besseli</code></dt>
<dd>
<p>Modified Bessel functions of the first kind.  If the argument <var>opt</var> is 1
or true, the result is multiplied by <code>exp (-abs (real (<var>x</var>)))</code>.
</p>
</dd>
<dt><code>besselk</code></dt>
<dd>
<p>Modified Bessel functions of the second kind.  If the argument <var>opt</var> is 1
or true, the result is multiplied by <code>exp (<var>x</var>)</code>.
</p>
</dd>
<dt><code>besselh</code></dt>
<dd><p>Compute Hankel functions of the first (<var>k</var> = 1) or second (<var>k</var>
= 2) kind.  If the argument <var>opt</var> is 1 or true, the result is multiplied
by <code>exp (-I*<var>x</var>)</code> for <var>k</var> = 1 or <code>exp (I*<var>x</var>)</code> for
<var>k</var> = 2.
</p></dd>
</dl>

<p>If <var>alpha</var> is a scalar, the result is the same size as <var>x</var>.
If <var>x</var> is a scalar, the result is the same size as <var>alpha</var>.
If <var>alpha</var> is a row vector and <var>x</var> is a column vector, the
result is a matrix with <code>length (<var>x</var>)</code> rows and
<code>length (<var>alpha</var>)</code> columns.  Otherwise, <var>alpha</var> and
<var>x</var> must conform and the result will be the same size.
</p>
<p>The value of <var>alpha</var> must be real.  The value of <var>x</var> may be
complex.
</p>
<p>If requested, <var>ierr</var> contains the following status information
and is the same size as the result.
</p>
<ol>
<li> Normal return.

</li><li> Input error, return <code>NaN</code>.

</li><li> Overflow, return <code>Inf</code>.

</li><li> Loss of significance by argument reduction results in less than
half of machine accuracy.

</li><li> Complete loss of significance by argument reduction, return <code>NaN</code>.

</li><li> Error&mdash;no computation, algorithm termination condition not met,
return <code>NaN</code>.
</li></ol>
</dd></dl>


<a name="XREFbeta"></a><dl>
<dt><a name="index-beta"></a>Mapping Function: <em></em> <strong>beta</strong> <em>(<var>a</var>, <var>b</var>)</em></dt>
<dd><p>Compute the Beta function for real inputs <var>a</var> and <var>b</var>.
</p>
<p>The Beta function definition is
</p>
<div class="example">
<pre class="example">beta (a, b) = gamma (a) * gamma (b) / gamma (a + b).
</pre></div>


<p>The Beta function can grow quite large and it is often more useful to work
with the logarithm of the output rather than the function directly.
See <a href="#XREFbetaln">betaln</a>, for computing the logarithm of the Beta function
in an efficient manner.
</p>
<p><strong>See also:</strong> <a href="#XREFbetaln">betaln</a>, <a href="#XREFbetainc">betainc</a>, <a href="#XREFbetaincinv">betaincinv</a>.
</p></dd></dl>


<a name="XREFbetainc"></a><dl>
<dt><a name="index-betainc"></a>Mapping Function: <em></em> <strong>betainc</strong> <em>(<var>x</var>, <var>a</var>, <var>b</var>)</em></dt>
<dd><p>Compute the regularized incomplete Beta function.
</p>
<p>The regularized incomplete Beta function is defined by
</p>
<div class="smallexample">
<pre class="smallexample">                                   x
                          1       /
betainc (x, a, b) = -----------   | t^(a-1) (1-t)^(b-1) dt.
                    beta (a, b)   /
                               t=0
</pre></div>


<p>If <var>x</var> has more than one component, both <var>a</var> and <var>b</var> must be
scalars.  If <var>x</var> is a scalar, <var>a</var> and <var>b</var> must be of
compatible dimensions.
</p>
<p><strong>See also:</strong> <a href="#XREFbetaincinv">betaincinv</a>, <a href="#XREFbeta">beta</a>, <a href="#XREFbetaln">betaln</a>.
</p></dd></dl>


<a name="XREFbetaincinv"></a><dl>
<dt><a name="index-betaincinv"></a>Mapping Function: <em></em> <strong>betaincinv</strong> <em>(<var>y</var>, <var>a</var>, <var>b</var>)</em></dt>
<dd><p>Compute the inverse of the incomplete Beta function.
</p>
<p>The inverse is the value <var>x</var> such that
</p>
<div class="example">
<pre class="example"><var>y</var> == betainc (<var>x</var>, <var>a</var>, <var>b</var>)
</pre></div>

<p><strong>See also:</strong> <a href="#XREFbetainc">betainc</a>, <a href="#XREFbeta">beta</a>, <a href="#XREFbetaln">betaln</a>.
</p></dd></dl>


<a name="XREFbetaln"></a><dl>
<dt><a name="index-betaln"></a>Mapping Function: <em></em> <strong>betaln</strong> <em>(<var>a</var>, <var>b</var>)</em></dt>
<dd><p>Compute the natural logarithm of the Beta function for real inputs <var>a</var>
and <var>b</var>.
</p>
<p><code>betaln</code> is defined as
</p>
<div class="example">
<pre class="example">betaln (a, b) = log (beta (a, b))
</pre></div>

<p>and is calculated in a way to reduce the occurrence of underflow.
</p>
<p>The Beta function can grow quite large and it is often more useful to work
with the logarithm of the output rather than the function directly.
</p>
<p><strong>See also:</strong> <a href="#XREFbeta">beta</a>, <a href="#XREFbetainc">betainc</a>, <a href="#XREFbetaincinv">betaincinv</a>, <a href="#XREFgammaln">gammaln</a>.
</p></dd></dl>


<a name="XREFbincoeff"></a><dl>
<dt><a name="index-bincoeff"></a>Mapping Function: <em></em> <strong>bincoeff</strong> <em>(<var>n</var>, <var>k</var>)</em></dt>
<dd><p>Return the binomial coefficient of <var>n</var> and <var>k</var>, defined as
</p>
<div class="example">
<pre class="example"> /   \
 | n |    n (n-1) (n-2) &hellip; (n-k+1)
 |   |  = -------------------------
 | k |               k!
 \   /
</pre></div>

<p>For example:
</p>
<div class="example">
<pre class="example">bincoeff (5, 2)
   &rArr; 10
</pre></div>

<p>In most cases, the <code>nchoosek</code> function is faster for small
scalar integer arguments.  It also warns about loss of precision for
big arguments.
</p>

<p><strong>See also:</strong> <a href="Basic-Statistical-Functions.html#XREFnchoosek">nchoosek</a>.
</p></dd></dl>


<a name="XREFcommutation_005fmatrix"></a><dl>
<dt><a name="index-commutation_005fmatrix"></a>Function File: <em></em> <strong>commutation_matrix</strong> <em>(<var>m</var>, <var>n</var>)</em></dt>
<dd><p>Return the commutation matrix
K(m,n)
which is the unique
<var>m</var>*<var>n</var> by <var>m</var>*<var>n</var>
matrix such that
<em>K(m,n) * vec(A) = vec(A')</em>
for all
<em>m</em> by <em>n</em>
matrices
<em>A</em>.
</p>
<p>If only one argument <var>m</var> is given,
<em>K(m,m)</em>
is returned.
</p>
<p>See Magnus and Neudecker (1988), <cite>Matrix Differential
Calculus with Applications in Statistics and Econometrics.</cite>
</p></dd></dl>


<a name="XREFduplication_005fmatrix"></a><dl>
<dt><a name="index-duplication_005fmatrix"></a>Function File: <em></em> <strong>duplication_matrix</strong> <em>(<var>n</var>)</em></dt>
<dd><p>Return the duplication matrix
<em>Dn</em>
which is the unique
<em>n^2</em> by <em>n*(n+1)/2</em>
matrix such that
<em>Dn vech (A) = vec (A)</em>
for all symmetric
<em>n</em> by <em>n</em>
matrices
<em>A</em>.
</p>
<p>See Magnus and Neudecker (1988), <cite>Matrix Differential
Calculus with Applications in Statistics and Econometrics.</cite>
</p></dd></dl>


<a name="XREFdawson"></a><dl>
<dt><a name="index-dawson"></a>Mapping Function: <em></em> <strong>dawson</strong> <em>(<var>z</var>)</em></dt>
<dd><p>Compute the Dawson (scaled imaginary error) function.
</p>
<p>The Dawson function is defined as
</p>
<div class="example">
<pre class="example">(sqrt (pi) / 2) * exp (-z^2) * erfi (z)
</pre></div>


<p><strong>See also:</strong> <a href="#XREFerfc">erfc</a>, <a href="#XREFerf">erf</a>, <a href="#XREFerfcx">erfcx</a>, <a href="#XREFerfi">erfi</a>, <a href="#XREFerfinv">erfinv</a>, <a href="#XREFerfcinv">erfcinv</a>.
</p></dd></dl>


<a name="XREFellipj"></a><dl>
<dt><a name="index-ellipj"></a>Built-in Function: <em>[<var>sn</var>, <var>cn</var>, <var>dn</var>, <var>err</var>] =</em> <strong>ellipj</strong> <em>(<var>u</var>, <var>m</var>)</em></dt>
<dt><a name="index-ellipj-1"></a>Built-in Function: <em>[<var>sn</var>, <var>cn</var>, <var>dn</var>, <var>err</var>] =</em> <strong>ellipj</strong> <em>(<var>u</var>, <var>m</var>, <var>tol</var>)</em></dt>
<dd><p>Compute the Jacobi elliptic functions <var>sn</var>, <var>cn</var>, and <var>dn</var>
of complex argument <var>u</var> and real parameter <var>m</var>.
</p>
<p>If <var>m</var> is a scalar, the results are the same size as <var>u</var>.
If <var>u</var> is a scalar, the results are the same size as <var>m</var>.
If <var>u</var> is a column vector and <var>m</var> is a row vector, the
results are matrices with <code>length (<var>u</var>)</code> rows and
<code>length (<var>m</var>)</code> columns.  Otherwise, <var>u</var> and
<var>m</var> must conform in size and the results will be the same size as the
inputs.
</p>
<p>The value of <var>u</var> may be complex.
The value of <var>m</var> must be 0 &le; <var>m</var> &le; 1.
</p>
<p>The optional input <var>tol</var> is currently ignored (<small>MATLAB</small> uses this to
allow faster, less accurate approximation).
</p>
<p>If requested, <var>err</var> contains the following status information
and is the same size as the result.
</p>
<ol>
<li> Normal return.

</li><li> Error&mdash;no computation, algorithm termination condition not met,
return <code>NaN</code>.
</li></ol>

<p>Reference: Milton Abramowitz and Irene A Stegun,
<cite>Handbook of Mathematical Functions</cite>, Chapter 16 (Sections 16.4, 16.13,
and 16.15), Dover, 1965.
</p>

<p><strong>See also:</strong> <a href="#XREFellipke">ellipke</a>.
</p></dd></dl>


<a name="XREFellipke"></a><dl>
<dt><a name="index-ellipke"></a>Function File: <em><var>k</var> =</em> <strong>ellipke</strong> <em>(<var>m</var>)</em></dt>
<dt><a name="index-ellipke-1"></a>Function File: <em><var>k</var> =</em> <strong>ellipke</strong> <em>(<var>m</var>, <var>tol</var>)</em></dt>
<dt><a name="index-ellipke-2"></a>Function File: <em>[<var>k</var>, <var>e</var>] =</em> <strong>ellipke</strong> <em>(&hellip;)</em></dt>
<dd><p>Compute complete elliptic integrals of the first K(<var>m</var>) and second
E(<var>m</var>) kind.
</p>
<p><var>m</var> must be a scalar or real array with -Inf &le; <var>m</var> &le; 1.
</p>
<p>The optional input <var>tol</var> controls the stopping tolerance of the
algorithm and defaults to <code>eps (class (<var>m</var>))</code>.  The tolerance can
be increased to compute a faster, less accurate approximation.
</p>
<p>When called with one output only elliptic integrals of the first kind are
returned.
</p>
<p>Mathematical Note:
</p>
<p>Elliptic integrals of the first kind are defined as
</p>

<div class="example">
<pre class="example">         1
        /               dt
K (m) = | ------------------------------
        / sqrt ((1 - t^2)*(1 - m*t^2))
       0
</pre></div>


<p>Elliptic integrals of the second kind are defined as
</p>

<div class="example">
<pre class="example">         1
        /  sqrt (1 - m*t^2)
E (m) = |  ------------------ dt
        /  sqrt (1 - t^2)
       0
</pre></div>


<p>Reference: Milton Abramowitz and Irene A. Stegun,
<cite>Handbook of Mathematical Functions</cite>, Chapter 17, Dover, 1965.
</p>
<p><strong>See also:</strong> <a href="#XREFellipj">ellipj</a>.
</p></dd></dl>


<a name="XREFerf"></a><dl>
<dt><a name="index-erf"></a>Mapping Function: <em></em> <strong>erf</strong> <em>(<var>z</var>)</em></dt>
<dd><p>Compute the error function.
</p>
<p>The error function is defined as
</p>
<div class="example">
<pre class="example">                        z
              2        /
erf (z) = --------- *  | e^(-t^2) dt
          sqrt (pi)    /
                    t=0
</pre></div>


<p><strong>See also:</strong> <a href="#XREFerfc">erfc</a>, <a href="#XREFerfcx">erfcx</a>, <a href="#XREFerfi">erfi</a>, <a href="#XREFdawson">dawson</a>, <a href="#XREFerfinv">erfinv</a>, <a href="#XREFerfcinv">erfcinv</a>.
</p></dd></dl>


<a name="XREFerfc"></a><dl>
<dt><a name="index-erfc"></a>Mapping Function: <em></em> <strong>erfc</strong> <em>(<var>z</var>)</em></dt>
<dd><p>Compute the complementary error function.
</p>
<p>The complementary error function is defined as
<code>1&nbsp;<span class="nolinebreak">-</span>&nbsp;erf&nbsp;(<var>z</var>)</code><!-- /@w -->.
</p>
<p><strong>See also:</strong> <a href="#XREFerfcinv">erfcinv</a>, <a href="#XREFerfcx">erfcx</a>, <a href="#XREFerfi">erfi</a>, <a href="#XREFdawson">dawson</a>, <a href="#XREFerf">erf</a>, <a href="#XREFerfinv">erfinv</a>.
</p></dd></dl>


<a name="XREFerfcx"></a><dl>
<dt><a name="index-erfcx"></a>Mapping Function: <em></em> <strong>erfcx</strong> <em>(<var>z</var>)</em></dt>
<dd><p>Compute the scaled complementary error function.
</p>
<p>The scaled complementary error function is defined as
</p>
<div class="example">
<pre class="example">exp (z^2) * erfc (z)
</pre></div>


<p><strong>See also:</strong> <a href="#XREFerfc">erfc</a>, <a href="#XREFerf">erf</a>, <a href="#XREFerfi">erfi</a>, <a href="#XREFdawson">dawson</a>, <a href="#XREFerfinv">erfinv</a>, <a href="#XREFerfcinv">erfcinv</a>.
</p></dd></dl>


<a name="XREFerfi"></a><dl>
<dt><a name="index-erfi"></a>Mapping Function: <em></em> <strong>erfi</strong> <em>(<var>z</var>)</em></dt>
<dd><p>Compute the imaginary error function.
</p>
<p>The imaginary error function is defined as
</p>
<div class="example">
<pre class="example">-i * erf (i*z)
</pre></div>


<p><strong>See also:</strong> <a href="#XREFerfc">erfc</a>, <a href="#XREFerf">erf</a>, <a href="#XREFerfcx">erfcx</a>, <a href="#XREFdawson">dawson</a>, <a href="#XREFerfinv">erfinv</a>, <a href="#XREFerfcinv">erfcinv</a>.
</p></dd></dl>


<a name="XREFerfinv"></a><dl>
<dt><a name="index-erfinv"></a>Mapping Function: <em></em> <strong>erfinv</strong> <em>(<var>x</var>)</em></dt>
<dd><p>Compute the inverse error function.
</p>
<p>The inverse error function is defined such that
</p>
<div class="example">
<pre class="example">erf (<var>y</var>) == <var>x</var>
</pre></div>

<p><strong>See also:</strong> <a href="#XREFerf">erf</a>, <a href="#XREFerfc">erfc</a>, <a href="#XREFerfcx">erfcx</a>, <a href="#XREFerfi">erfi</a>, <a href="#XREFdawson">dawson</a>, <a href="#XREFerfcinv">erfcinv</a>.
</p></dd></dl>


<a name="XREFerfcinv"></a><dl>
<dt><a name="index-erfcinv"></a>Mapping Function: <em></em> <strong>erfcinv</strong> <em>(<var>x</var>)</em></dt>
<dd><p>Compute the inverse complementary error function.
</p>
<p>The inverse complementary error function is defined such that
</p>
<div class="example">
<pre class="example">erfc (<var>y</var>) == <var>x</var>
</pre></div>

<p><strong>See also:</strong> <a href="#XREFerfc">erfc</a>, <a href="#XREFerf">erf</a>, <a href="#XREFerfcx">erfcx</a>, <a href="#XREFerfi">erfi</a>, <a href="#XREFdawson">dawson</a>, <a href="#XREFerfinv">erfinv</a>.
</p></dd></dl>


<a name="XREFexpint"></a><dl>
<dt><a name="index-expint"></a>Function File: <em></em> <strong>expint</strong> <em>(<var>x</var>)</em></dt>
<dd><p>Compute the exponential integral:
</p>
<div class="example">
<pre class="example">           infinity
          /
E_1 (x) = | exp (-t)/t dt
          /
         x
</pre></div>

<p>Note: For compatibility, this functions uses the <small>MATLAB</small> definition
of the exponential integral.  Most other sources refer to this particular
value as <em>E_1 (x)</em>, and the exponential integral as
</p>
<div class="example">
<pre class="example">            infinity
           /
Ei (x) = - | exp (-t)/t dt
           /
         -x
</pre></div>

<p>The two definitions are related, for positive real values of <var>x</var>, by
<code><span class="nolinebreak">E_1</span>&nbsp;<span class="nolinebreak">(-x)</span>&nbsp;=&nbsp;<span class="nolinebreak">-Ei</span>&nbsp;(x)&nbsp;<span class="nolinebreak">-</span>&nbsp;i*pi</code><!-- /@w -->.
</p></dd></dl>


<a name="XREFgamma"></a><dl>
<dt><a name="index-gamma"></a>Mapping Function: <em></em> <strong>gamma</strong> <em>(<var>z</var>)</em></dt>
<dd><p>Compute the Gamma function.
</p>
<p>The Gamma function is defined as
</p>
<div class="example">
<pre class="example">             infinity
            /
gamma (z) = | t^(z-1) exp (-t) dt.
            /
         t=0
</pre></div>


<p>Programming Note: The gamma function can grow quite large even for small
input values.  In many cases it may be preferable to use the natural
logarithm of the gamma function (<code>gammaln</code>) in calculations to minimize
loss of precision.  The final result is then
<code>exp (<var>result_using_gammaln</var>).</code>
</p>
<p><strong>See also:</strong> <a href="#XREFgammainc">gammainc</a>, <a href="#XREFgammaln">gammaln</a>, <a href="Utility-Functions.html#XREFfactorial">factorial</a>.
</p></dd></dl>


<a name="XREFgammainc"></a><dl>
<dt><a name="index-gammainc"></a>Mapping Function: <em></em> <strong>gammainc</strong> <em>(<var>x</var>, <var>a</var>)</em></dt>
<dt><a name="index-gammainc-1"></a>Mapping Function: <em></em> <strong>gammainc</strong> <em>(<var>x</var>, <var>a</var>, &quot;lower&quot;)</em></dt>
<dt><a name="index-gammainc-2"></a>Mapping Function: <em></em> <strong>gammainc</strong> <em>(<var>x</var>, <var>a</var>, &quot;upper&quot;)</em></dt>
<dd><p>Compute the normalized incomplete gamma function.
</p>
<p>This is defined as
</p>
<div class="example">
<pre class="example">                                x
                       1       /
gammainc (x, a) = ---------    | exp (-t) t^(a-1) dt
                  gamma (a)    /
                            t=0
</pre></div>

<p>with the limiting value of 1 as <var>x</var> approaches infinity.
The standard notation is <em>P(a,x)</em>, e.g., Abramowitz and
Stegun (6.5.1).
</p>
<p>If <var>a</var> is scalar, then <code>gammainc (<var>x</var>, <var>a</var>)</code> is returned
for each element of <var>x</var> and vice versa.
</p>
<p>If neither <var>x</var> nor <var>a</var> is scalar, the sizes of <var>x</var> and
<var>a</var> must agree, and <code>gammainc</code> is applied element-by-element.
</p>
<p>By default the incomplete gamma function integrated from 0 to <var>x</var> is
computed.  If <code>&quot;upper&quot;</code> is given then the complementary function
integrated from <var>x</var> to infinity is calculated.  It should be noted that
</p>
<div class="example">
<pre class="example">gammainc (<var>x</var>, <var>a</var>) &equiv; 1 - gammainc (<var>x</var>, <var>a</var>, &quot;upper&quot;)
</pre></div>

<p><strong>See also:</strong> <a href="#XREFgamma">gamma</a>, <a href="#XREFgammaln">gammaln</a>.
</p></dd></dl>


<a name="XREFlegendre"></a><dl>
<dt><a name="index-legendre"></a>Function File: <em><var>l</var> =</em> <strong>legendre</strong> <em>(<var>n</var>, <var>x</var>)</em></dt>
<dt><a name="index-legendre-1"></a>Function File: <em><var>l</var> =</em> <strong>legendre</strong> <em>(<var>n</var>, <var>x</var>, <var>normalization</var>)</em></dt>
<dd><p>Compute the Legendre function of degree <var>n</var> and order
<var>m</var> = 0 &hellip; <var>n</var>.
</p>
<p>The value <var>n</var> must be a real non-negative integer.
</p>
<p><var>x</var> is a vector with real-valued elements in the range [-1, 1].
</p>
<p>The optional argument <var>normalization</var> may be one of <code>&quot;unnorm&quot;</code>,
<code>&quot;sch&quot;</code>, or <code>&quot;norm&quot;</code>.  The default if no normalization is given
is <code>&quot;unnorm&quot;</code>.
</p>
<p>When the optional argument <var>normalization</var> is <code>&quot;unnorm&quot;</code>, compute
the Legendre function of degree <var>n</var> and order <var>m</var> and return all
values for <var>m</var> = 0 &hellip; <var>n</var>.  The return value has one dimension
more than <var>x</var>.
</p>
<p>The Legendre Function of degree <var>n</var> and order <var>m</var>:
</p>

<div class="example">
<pre class="example"> m         m      2  m/2   d^m
P(x) = (-1) * (1-x  )    * ----  P(x)
 n                         dx^m   n
</pre></div>


<p>with Legendre polynomial of degree <var>n</var>:
</p>

<div class="example">
<pre class="example">          1    d^n   2    n
P(x) = ------ [----(x - 1) ]
 n     2^n n!  dx^n
</pre></div>


<p><code>legendre (3, [-1.0, -0.9, -0.8])</code> returns the matrix:
</p>
<div class="example">
<pre class="example"> x  |   -1.0   |   -0.9   |   -0.8
------------------------------------
m=0 | -1.00000 | -0.47250 | -0.08000
m=1 |  0.00000 | -1.99420 | -1.98000
m=2 |  0.00000 | -2.56500 | -4.32000
m=3 |  0.00000 | -1.24229 | -3.24000
</pre></div>

<p>When the optional argument <code>normalization</code> is <code>&quot;sch&quot;</code>, compute
the Schmidt semi-normalized associated Legendre function.  The Schmidt
semi-normalized associated Legendre function is related to the unnormalized
Legendre functions by the following:
</p>
<p>For Legendre functions of degree <var>n</var> and order 0:
</p>

<div class="example">
<pre class="example">  0      0
SP(x) = P(x)
  n      n
</pre></div>


<p>For Legendre functions of degree n and order m:
</p>

<div class="example">
<pre class="example">  m      m         m    2(n-m)! 0.5
SP(x) = P(x) * (-1)  * [-------]
  n      n              (n+m)!
</pre></div>


<p>When the optional argument <var>normalization</var> is <code>&quot;norm&quot;</code>, compute
the fully normalized associated Legendre function.  The fully normalized
associated Legendre function is related to the unnormalized Legendre
functions by the following:
</p>
<p>For Legendre functions of degree <var>n</var> and order <var>m</var>
</p>

<div class="example">
<pre class="example">  m      m         m    (n+0.5)(n-m)! 0.5
NP(x) = P(x) * (-1)  * [-------------]
  n      n                  (n+m)!
</pre></div>

</dd></dl>


<a name="XREFgammaln"></a><a name="XREFlgamma"></a><dl>
<dt><a name="index-gammaln"></a>Mapping Function: <em></em> <strong>gammaln</strong> <em>(<var>x</var>)</em></dt>
<dt><a name="index-lgamma"></a>Mapping Function: <em></em> <strong>lgamma</strong> <em>(<var>x</var>)</em></dt>
<dd><p>Return the natural logarithm of the gamma function of <var>x</var>.
</p>
<p><strong>See also:</strong> <a href="#XREFgamma">gamma</a>, <a href="#XREFgammainc">gammainc</a>.
</p></dd></dl>


<hr>
<div class="header">
<p>
Next: <a href="Rational-Approximations.html#Rational-Approximations" accesskey="n" rel="next">Rational Approximations</a>, Previous: <a href="Utility-Functions.html#Utility-Functions" accesskey="p" rel="prev">Utility Functions</a>, Up: <a href="Arithmetic.html#Arithmetic" accesskey="u" rel="up">Arithmetic</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
