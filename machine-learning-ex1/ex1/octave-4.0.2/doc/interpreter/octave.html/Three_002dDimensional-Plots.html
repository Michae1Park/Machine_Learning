<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>GNU Octave: Three-Dimensional Plots</title>

<meta name="description" content="GNU Octave: Three-Dimensional Plots">
<meta name="keywords" content="GNU Octave: Three-Dimensional Plots">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="High_002dLevel-Plotting.html#High_002dLevel-Plotting" rel="up" title="High-Level Plotting">
<link href="Aspect-Ratio.html#Aspect-Ratio" rel="next" title="Aspect Ratio">
<link href="Two_002ddimensional-Geometric-Shapes.html#Two_002ddimensional-Geometric-Shapes" rel="prev" title="Two-dimensional Geometric Shapes">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<a name="Three_002dDimensional-Plots"></a>
<div class="header">
<p>
Next: <a href="Plot-Annotations.html#Plot-Annotations" accesskey="n" rel="next">Plot Annotations</a>, Previous: <a href="Two_002dDimensional-Plots.html#Two_002dDimensional-Plots" accesskey="p" rel="prev">Two-Dimensional Plots</a>, Up: <a href="High_002dLevel-Plotting.html#High_002dLevel-Plotting" accesskey="u" rel="up">High-Level Plotting</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Three_002dDimensional-Plots-1"></a>
<h4 class="subsection">15.2.2 Three-Dimensional Plots</h4>
<a name="index-plotting_002c-three_002ddimensional"></a>

<p>The function <code>mesh</code> produces mesh surface plots.  For example,
</p>
<div class="example">
<pre class="example">tx = ty = linspace (-8, 8, 41)';
[xx, yy] = meshgrid (tx, ty);
r = sqrt (xx .^ 2 + yy .^ 2) + eps;
tz = sin (r) ./ r;
mesh (tx, ty, tz);
</pre></div>

<p>produces the familiar &ldquo;sombrero&rdquo; plot shown in <a href="#fig_003amesh">Figure 15.5</a>.  Note
the use of the function <code>meshgrid</code> to create matrices of X and Y
coordinates to use for plotting the Z data.  The <code>ndgrid</code> function
is similar to <code>meshgrid</code>, but works for N-dimensional matrices.
</p>
<div class="float"><a name="fig_003amesh"></a>
<div align="center"><img src="mesh.png" alt="mesh">
</div>
<div class="float-caption"><p><strong>Figure 15.5: </strong>Mesh plot.</p></div></div>
<p>The <code>meshc</code> function is similar to <code>mesh</code>, but also produces a
plot of contours for the surface.
</p>
<p>The <code>plot3</code> function displays arbitrary three-dimensional data,
without requiring it to form a surface.  For example,
</p>
<div class="example">
<pre class="example">t = 0:0.1:10*pi;
r = linspace (0, 1, numel (t));
z = linspace (0, 1, numel (t));
plot3 (r.*sin(t), r.*cos(t), z);
</pre></div>

<p>displays the spiral in three dimensions shown in <a href="#fig_003aplot3">Figure 15.6</a>.
</p>
<div class="float"><a name="fig_003aplot3"></a>
<div align="center"><img src="plot3.png" alt="plot3">
</div>
<div class="float-caption"><p><strong>Figure 15.6: </strong>Three-dimensional spiral.</p></div></div>
<p>Finally, the <code>view</code> function changes the viewpoint for
three-dimensional plots.
</p>
<a name="XREFmesh"></a><dl>
<dt><a name="index-mesh"></a>Function File: <em></em> <strong>mesh</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>)</em></dt>
<dt><a name="index-mesh-1"></a>Function File: <em></em> <strong>mesh</strong> <em>(<var>z</var>)</em></dt>
<dt><a name="index-mesh-2"></a>Function File: <em></em> <strong>mesh</strong> <em>(&hellip;, <var>c</var>)</em></dt>
<dt><a name="index-mesh-3"></a>Function File: <em></em> <strong>mesh</strong> <em>(&hellip;, <var>prop</var>, <var>val</var>, &hellip;)</em></dt>
<dt><a name="index-mesh-4"></a>Function File: <em></em> <strong>mesh</strong> <em>(<var>hax</var>, &hellip;)</em></dt>
<dt><a name="index-mesh-5"></a>Function File: <em><var>h</var> =</em> <strong>mesh</strong> <em>(&hellip;)</em></dt>
<dd><p>Plot a 3-D wireframe mesh.
</p>
<p>The wireframe mesh is plotted using rectangles.  The vertices of the
rectangles [<var>x</var>, <var>y</var>] are typically the output of <code>meshgrid</code>.
over a 2-D rectangular region in the x-y plane.  <var>z</var> determines the
height above the plane of each vertex.  If only a single <var>z</var> matrix is
given, then it is plotted over the meshgrid
<code><var>x</var> = 1:columns (<var>z</var>), <var>y</var> = 1:rows (<var>z</var>)</code>.
Thus, columns of <var>z</var> correspond to different <var>x</var> values and rows
of <var>z</var> correspond to different <var>y</var> values.
</p>
<p>The color of the mesh is computed by linearly scaling the <var>z</var> values
to fit the range of the current colormap.  Use <code>caxis</code> and/or
change the colormap to control the appearance.
</p>
<p>Optionally, the color of the mesh can be specified independently of <var>z</var>
by supplying a color matrix, <var>c</var>.
</p>
<p>Any property/value pairs are passed directly to the underlying surface
object.
</p>
<p>If the first argument <var>hax</var> is an axes handle, then plot into this axis,
rather than the current axes returned by <code>gca</code>.
</p>
<p>The optional return value <var>h</var> is a graphics handle to the created
surface object.
</p>

<p><strong>See also:</strong> <a href="Three_002ddimensional-Function-Plotting.html#XREFezmesh">ezmesh</a>, <a href="#XREFmeshc">meshc</a>, <a href="#XREFmeshz">meshz</a>, <a href="Plotting-the-Triangulation.html#XREFtrimesh">trimesh</a>, <a href="Two_002dDimensional-Plots.html#XREFcontour">contour</a>, <a href="#XREFsurf">surf</a>, <a href="Graphics-Objects.html#XREFsurface">surface</a>, <a href="#XREFmeshgrid">meshgrid</a>, <a href="#XREFhidden">hidden</a>, <a href="#XREFshading">shading</a>, <a href="Representing-Images.html#XREFcolormap">colormap</a>, <a href="Axis-Configuration.html#XREFcaxis">caxis</a>.
</p></dd></dl>


<a name="XREFmeshc"></a><dl>
<dt><a name="index-meshc"></a>Function File: <em></em> <strong>meshc</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>)</em></dt>
<dt><a name="index-meshc-1"></a>Function File: <em></em> <strong>meshc</strong> <em>(<var>z</var>)</em></dt>
<dt><a name="index-meshc-2"></a>Function File: <em></em> <strong>meshc</strong> <em>(&hellip;, <var>c</var>)</em></dt>
<dt><a name="index-meshc-3"></a>Function File: <em></em> <strong>meshc</strong> <em>(&hellip;, <var>prop</var>, <var>val</var>, &hellip;)</em></dt>
<dt><a name="index-meshc-4"></a>Function File: <em></em> <strong>meshc</strong> <em>(<var>hax</var>, &hellip;)</em></dt>
<dt><a name="index-meshc-5"></a>Function File: <em><var>h</var> =</em> <strong>meshc</strong> <em>(&hellip;)</em></dt>
<dd><p>Plot a 3-D wireframe mesh with underlying contour lines.
</p>
<p>The wireframe mesh is plotted using rectangles.  The vertices of the
rectangles [<var>x</var>, <var>y</var>] are typically the output of <code>meshgrid</code>.
over a 2-D rectangular region in the x-y plane.  <var>z</var> determines the
height above the plane of each vertex.  If only a single <var>z</var> matrix is
given, then it is plotted over the meshgrid
<code><var>x</var> = 1:columns (<var>z</var>), <var>y</var> = 1:rows (<var>z</var>)</code>.
Thus, columns of <var>z</var> correspond to different <var>x</var> values and rows
of <var>z</var> correspond to different <var>y</var> values.
</p>
<p>The color of the mesh is computed by linearly scaling the <var>z</var> values
to fit the range of the current colormap.  Use <code>caxis</code> and/or
change the colormap to control the appearance.
</p>
<p>Optionally the color of the mesh can be specified independently of <var>z</var>
by supplying a color matrix, <var>c</var>.
</p>
<p>Any property/value pairs are passed directly to the underlying surface
object.
</p>
<p>If the first argument <var>hax</var> is an axes handle, then plot into this axis,
rather than the current axes returned by <code>gca</code>.
</p>
<p>The optional return value <var>h</var> is a 2-element vector with a graphics
handle to the created surface object and to the created contour plot.
</p>

<p><strong>See also:</strong> <a href="Three_002ddimensional-Function-Plotting.html#XREFezmeshc">ezmeshc</a>, <a href="#XREFmesh">mesh</a>, <a href="#XREFmeshz">meshz</a>, <a href="Two_002dDimensional-Plots.html#XREFcontour">contour</a>, <a href="#XREFsurfc">surfc</a>, <a href="Graphics-Objects.html#XREFsurface">surface</a>, <a href="#XREFmeshgrid">meshgrid</a>, <a href="#XREFhidden">hidden</a>, <a href="#XREFshading">shading</a>, <a href="Representing-Images.html#XREFcolormap">colormap</a>, <a href="Axis-Configuration.html#XREFcaxis">caxis</a>.
</p></dd></dl>


<a name="XREFmeshz"></a><dl>
<dt><a name="index-meshz"></a>Function File: <em></em> <strong>meshz</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>)</em></dt>
<dt><a name="index-meshz-1"></a>Function File: <em></em> <strong>meshz</strong> <em>(<var>z</var>)</em></dt>
<dt><a name="index-meshz-2"></a>Function File: <em></em> <strong>meshz</strong> <em>(&hellip;, <var>c</var>)</em></dt>
<dt><a name="index-meshz-3"></a>Function File: <em></em> <strong>meshz</strong> <em>(&hellip;, <var>prop</var>, <var>val</var>, &hellip;)</em></dt>
<dt><a name="index-meshz-4"></a>Function File: <em></em> <strong>meshz</strong> <em>(<var>hax</var>, &hellip;)</em></dt>
<dt><a name="index-meshz-5"></a>Function File: <em><var>h</var> =</em> <strong>meshz</strong> <em>(&hellip;)</em></dt>
<dd><p>Plot a 3-D wireframe mesh with a surrounding curtain.
</p>
<p>The wireframe mesh is plotted using rectangles.  The vertices of the
rectangles [<var>x</var>, <var>y</var>] are typically the output of <code>meshgrid</code>.
over a 2-D rectangular region in the x-y plane.  <var>z</var> determines the
height above the plane of each vertex.  If only a single <var>z</var> matrix is
given, then it is plotted over the meshgrid
<code><var>x</var> = 0:columns (<var>z</var>) - 1, <var>y</var> = 0:rows (<var>z</var>) - 1</code>.
Thus, columns of <var>z</var> correspond to different <var>x</var> values and rows
of <var>z</var> correspond to different <var>y</var> values.
</p>
<p>The color of the mesh is computed by linearly scaling the <var>z</var> values
to fit the range of the current colormap.  Use <code>caxis</code> and/or
change the colormap to control the appearance.
</p>
<p>Optionally the color of the mesh can be specified independently of <var>z</var>
by supplying a color matrix, <var>c</var>.
</p>
<p>Any property/value pairs are passed directly to the underlying surface
object.
</p>
<p>If the first argument <var>hax</var> is an axes handle, then plot into this axis,
rather than the current axes returned by <code>gca</code>.
</p>
<p>The optional return value <var>h</var> is a graphics handle to the created
surface object.
</p>

<p><strong>See also:</strong> <a href="#XREFmesh">mesh</a>, <a href="#XREFmeshc">meshc</a>, <a href="Two_002dDimensional-Plots.html#XREFcontour">contour</a>, <a href="#XREFsurf">surf</a>, <a href="Graphics-Objects.html#XREFsurface">surface</a>, <a href="#XREFwaterfall">waterfall</a>, <a href="#XREFmeshgrid">meshgrid</a>, <a href="#XREFhidden">hidden</a>, <a href="#XREFshading">shading</a>, <a href="Representing-Images.html#XREFcolormap">colormap</a>, <a href="Axis-Configuration.html#XREFcaxis">caxis</a>.
</p></dd></dl>


<a name="XREFhidden"></a><dl>
<dt><a name="index-hidden"></a>Command: <em></em> <strong>hidden</strong></dt>
<dt><a name="index-hidden-1"></a>Command: <em></em> <strong>hidden</strong> <em>on</em></dt>
<dt><a name="index-hidden-2"></a>Command: <em></em> <strong>hidden</strong> <em>off</em></dt>
<dt><a name="index-hidden-3"></a>Function File: <em><var>mode</var> =</em> <strong>hidden</strong> <em>(&hellip;)</em></dt>
<dd><p>Control mesh hidden line removal.
</p>
<p>When called with no argument the hidden line removal state is toggled.
</p>
<p>When called with one of the modes <code>&quot;on&quot;</code> or <code>&quot;off&quot;</code> the state
is set accordingly.
</p>
<p>The optional output argument <var>mode</var> is the current state.
</p>
<p>Hidden Line Removal determines what graphic objects behind a mesh plot
are visible.  The default is for the mesh to be opaque and lines behind
the mesh are not visible.  If hidden line removal is turned off then
objects behind the mesh can be seen through the faces (openings) of the
mesh, although the mesh grid lines are still opaque.
</p>

<p><strong>See also:</strong> <a href="#XREFmesh">mesh</a>, <a href="#XREFmeshc">meshc</a>, <a href="#XREFmeshz">meshz</a>, <a href="Three_002ddimensional-Function-Plotting.html#XREFezmesh">ezmesh</a>, <a href="Three_002ddimensional-Function-Plotting.html#XREFezmeshc">ezmeshc</a>, <a href="Plotting-the-Triangulation.html#XREFtrimesh">trimesh</a>, <a href="#XREFwaterfall">waterfall</a>.
</p></dd></dl>


<a name="XREFsurf"></a><dl>
<dt><a name="index-surf"></a>Function File: <em></em> <strong>surf</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>)</em></dt>
<dt><a name="index-surf-1"></a>Function File: <em></em> <strong>surf</strong> <em>(<var>z</var>)</em></dt>
<dt><a name="index-surf-2"></a>Function File: <em></em> <strong>surf</strong> <em>(&hellip;, <var>c</var>)</em></dt>
<dt><a name="index-surf-3"></a>Function File: <em></em> <strong>surf</strong> <em>(&hellip;, <var>prop</var>, <var>val</var>, &hellip;)</em></dt>
<dt><a name="index-surf-4"></a>Function File: <em></em> <strong>surf</strong> <em>(<var>hax</var>, &hellip;)</em></dt>
<dt><a name="index-surf-5"></a>Function File: <em><var>h</var> =</em> <strong>surf</strong> <em>(&hellip;)</em></dt>
<dd><p>Plot a 3-D surface mesh.
</p>
<p>The surface mesh is plotted using shaded rectangles.  The vertices of the
rectangles [<var>x</var>, <var>y</var>] are typically the output of <code>meshgrid</code>.
over a 2-D rectangular region in the x-y plane.  <var>z</var> determines the
height above the plane of each vertex.  If only a single <var>z</var> matrix is
given, then it is plotted over the meshgrid
<code><var>x</var> = 1:columns (<var>z</var>), <var>y</var> = 1:rows (<var>z</var>)</code>.
Thus, columns of <var>z</var> correspond to different <var>x</var> values and rows
of <var>z</var> correspond to different <var>y</var> values.
</p>
<p>The color of the surface is computed by linearly scaling the <var>z</var> values
to fit the range of the current colormap.  Use <code>caxis</code> and/or
change the colormap to control the appearance.
</p>
<p>Optionally, the color of the surface can be specified independently of
<var>z</var> by supplying a color matrix, <var>c</var>.
</p>
<p>Any property/value pairs are passed directly to the underlying surface
object.
</p>
<p>If the first argument <var>hax</var> is an axes handle, then plot into this axis,
rather than the current axes returned by <code>gca</code>.
</p>
<p>The optional return value <var>h</var> is a graphics handle to the created
surface object.
</p>
<p>Note: The exact appearance of the surface can be controlled with the
<code>shading</code> command or by using <code>set</code> to control surface object
properties.
</p>
<p><strong>See also:</strong> <a href="Three_002ddimensional-Function-Plotting.html#XREFezsurf">ezsurf</a>, <a href="#XREFsurfc">surfc</a>, <a href="#XREFsurfl">surfl</a>, <a href="#XREFsurfnorm">surfnorm</a>, <a href="Plotting-the-Triangulation.html#XREFtrisurf">trisurf</a>, <a href="Two_002dDimensional-Plots.html#XREFcontour">contour</a>, <a href="#XREFmesh">mesh</a>, <a href="Graphics-Objects.html#XREFsurface">surface</a>, <a href="#XREFmeshgrid">meshgrid</a>, <a href="#XREFhidden">hidden</a>, <a href="#XREFshading">shading</a>, <a href="Representing-Images.html#XREFcolormap">colormap</a>, <a href="Axis-Configuration.html#XREFcaxis">caxis</a>.
</p></dd></dl>


<a name="XREFsurfc"></a><dl>
<dt><a name="index-surfc"></a>Function File: <em></em> <strong>surfc</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>)</em></dt>
<dt><a name="index-surfc-1"></a>Function File: <em></em> <strong>surfc</strong> <em>(<var>z</var>)</em></dt>
<dt><a name="index-surfc-2"></a>Function File: <em></em> <strong>surfc</strong> <em>(&hellip;, <var>c</var>)</em></dt>
<dt><a name="index-surfc-3"></a>Function File: <em></em> <strong>surfc</strong> <em>(&hellip;, <var>prop</var>, <var>val</var>, &hellip;)</em></dt>
<dt><a name="index-surfc-4"></a>Function File: <em></em> <strong>surfc</strong> <em>(<var>hax</var>, &hellip;)</em></dt>
<dt><a name="index-surfc-5"></a>Function File: <em><var>h</var> =</em> <strong>surfc</strong> <em>(&hellip;)</em></dt>
<dd><p>Plot a 3-D surface mesh with underlying contour lines.
</p>
<p>The surface mesh is plotted using shaded rectangles.  The vertices of the
rectangles [<var>x</var>, <var>y</var>] are typically the output of <code>meshgrid</code>.
over a 2-D rectangular region in the x-y plane.  <var>z</var> determines the
height above the plane of each vertex.  If only a single <var>z</var> matrix is
given, then it is plotted over the meshgrid
<code><var>x</var> = 1:columns (<var>z</var>), <var>y</var> = 1:rows (<var>z</var>)</code>.
Thus, columns of <var>z</var> correspond to different <var>x</var> values and rows
of <var>z</var> correspond to different <var>y</var> values.
</p>
<p>The color of the surface is computed by linearly scaling the <var>z</var> values
to fit the range of the current colormap.  Use <code>caxis</code> and/or
change the colormap to control the appearance.
</p>
<p>Optionally, the color of the surface can be specified independently of
<var>z</var> by supplying a color matrix, <var>c</var>.
</p>
<p>Any property/value pairs are passed directly to the underlying surface
object.
</p>
<p>If the first argument <var>hax</var> is an axes handle, then plot into this axis,
rather than the current axes returned by <code>gca</code>.
</p>
<p>The optional return value <var>h</var> is a graphics handle to the created
surface object.
</p>
<p>Note: The exact appearance of the surface can be controlled with the
<code>shading</code> command or by using <code>set</code> to control surface object
properties.
</p>
<p><strong>See also:</strong> <a href="Three_002ddimensional-Function-Plotting.html#XREFezsurfc">ezsurfc</a>, <a href="#XREFsurf">surf</a>, <a href="#XREFsurfl">surfl</a>, <a href="#XREFsurfnorm">surfnorm</a>, <a href="Plotting-the-Triangulation.html#XREFtrisurf">trisurf</a>, <a href="Two_002dDimensional-Plots.html#XREFcontour">contour</a>, <a href="#XREFmesh">mesh</a>, <a href="Graphics-Objects.html#XREFsurface">surface</a>, <a href="#XREFmeshgrid">meshgrid</a>, <a href="#XREFhidden">hidden</a>, <a href="#XREFshading">shading</a>, <a href="Representing-Images.html#XREFcolormap">colormap</a>, <a href="Axis-Configuration.html#XREFcaxis">caxis</a>.
</p></dd></dl>


<a name="XREFsurfl"></a><dl>
<dt><a name="index-surfl"></a>Function File: <em></em> <strong>surfl</strong> <em>(<var>z</var>)</em></dt>
<dt><a name="index-surfl-1"></a>Function File: <em></em> <strong>surfl</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>)</em></dt>
<dt><a name="index-surfl-2"></a>Function File: <em></em> <strong>surfl</strong> <em>(&hellip;, <var>lsrc</var>)</em></dt>
<dt><a name="index-surfl-3"></a>Function File: <em></em> <strong>surfl</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>lsrc</var>, <var>P</var>)</em></dt>
<dt><a name="index-surfl-4"></a>Function File: <em></em> <strong>surfl</strong> <em>(&hellip;, &quot;cdata&quot;)</em></dt>
<dt><a name="index-surfl-5"></a>Function File: <em></em> <strong>surfl</strong> <em>(&hellip;, &quot;light&quot;)</em></dt>
<dt><a name="index-surfl-6"></a>Function File: <em></em> <strong>surfl</strong> <em>(<var>hax</var>, &hellip;)</em></dt>
<dt><a name="index-surfl-7"></a>Function File: <em><var>h</var> =</em> <strong>surfl</strong> <em>(&hellip;)</em></dt>
<dd><p>Plot a 3-D surface using shading based on various lighting models.
</p>
<p>The surface mesh is plotted using shaded rectangles.  The vertices of the
rectangles [<var>x</var>, <var>y</var>] are typically the output of <code>meshgrid</code>.
over a 2-D rectangular region in the x-y plane.  <var>z</var> determines the
height above the plane of each vertex.  If only a single <var>z</var> matrix is
given, then it is plotted over the meshgrid
<code><var>x</var> = 1:columns (<var>z</var>), <var>y</var> = 1:rows (<var>z</var>)</code>.
Thus, columns of <var>z</var> correspond to different <var>x</var> values and rows
of <var>z</var> correspond to different <var>y</var> values.
</p>
<p>The default lighting mode <code>&quot;cdata&quot;</code>, changes the cdata property of the
surface object to give the impression of a lighted surface.
<strong>Warning:</strong> The alternative mode <code>&quot;light&quot;</code> mode which creates a
light object to illuminate the surface is not implemented (yet).
</p>
<p>The light source location can be specified using <var>lsrc</var>.  It can be given
as a 2-element vector [azimuth, elevation] in degrees, or as a 3-element
vector [lx, ly, lz].  The default value is rotated 45 degrees
counterclockwise to the current view.
</p>
<p>The material properties of the surface can specified using a 4-element
vector <var>P</var> = [<var>AM</var> <var>D</var> <var>SP</var> <var>exp</var>] which defaults to
<var>p</var> = [0.55 0.6 0.4 10].
</p>
<dl compact="compact">
<dt><code>&quot;AM&quot;</code> strength of ambient light</dt>
<dt><code>&quot;D&quot;</code> strength of diffuse reflection</dt>
<dt><code>&quot;SP&quot;</code> strength of specular reflection</dt>
<dt><code>&quot;EXP&quot;</code> specular exponent</dt>
</dl>

<p>If the first argument <var>hax</var> is an axes handle, then plot into this axis,
rather than the current axes returned by <code>gca</code>.
</p>
<p>The optional return value <var>h</var> is a graphics handle to the created
surface object.
</p>
<p>Example:
</p>
<div class="example">
<pre class="example">colormap (bone (64));
surfl (peaks);
shading interp;
</pre></div>

<p><strong>See also:</strong> <a href="#XREFdiffuse">diffuse</a>, <a href="#XREFspecular">specular</a>, <a href="#XREFsurf">surf</a>, <a href="#XREFshading">shading</a>, <a href="Representing-Images.html#XREFcolormap">colormap</a>, <a href="Axis-Configuration.html#XREFcaxis">caxis</a>.
</p></dd></dl>


<a name="XREFsurfnorm"></a><dl>
<dt><a name="index-surfnorm"></a>Function File: <em></em> <strong>surfnorm</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>)</em></dt>
<dt><a name="index-surfnorm-1"></a>Function File: <em></em> <strong>surfnorm</strong> <em>(<var>z</var>)</em></dt>
<dt><a name="index-surfnorm-2"></a>Function File: <em></em> <strong>surfnorm</strong> <em>(&hellip;, <var>prop</var>, <var>val</var>, &hellip;)</em></dt>
<dt><a name="index-surfnorm-3"></a>Function File: <em></em> <strong>surfnorm</strong> <em>(<var>hax</var>, &hellip;)</em></dt>
<dt><a name="index-surfnorm-4"></a>Function File: <em>[<var>nx</var>, <var>ny</var>, <var>nz</var>] =</em> <strong>surfnorm</strong> <em>(&hellip;)</em></dt>
<dd><p>Find the vectors normal to a meshgridded surface.
</p>
<p>If <var>x</var> and <var>y</var> are vectors, then a typical vertex is
(<var>x</var>(j), <var>y</var>(i), <var>z</var>(i,j)).  Thus, columns of <var>z</var> correspond
to different <var>x</var> values and rows of <var>z</var> correspond to different
<var>y</var> values.  If only a single input <var>z</var> is given then <var>x</var> is
taken to be <code>1:rows (<var>z</var>)</code> and <var>y</var> is
<code>1:columns (<var>z</var>)</code>.
</p>
<p>If no return arguments are requested, a surface plot with the normal
vectors to the surface is plotted.
</p>
<p>Any property/value input pairs are assigned to the surface object.
</p>
<p>If the first argument <var>hax</var> is an axes handle, then plot into this axis,
rather than the current axes returned by <code>gca</code>.
</p>
<p>If output arguments are requested then the components of the normal
vectors are returned in <var>nx</var>, <var>ny</var>, and <var>nz</var> and no plot is
made.
</p>
<p>An example of the use of <code>surfnorm</code> is
</p>
<div class="example">
<pre class="example">surfnorm (peaks (25));
</pre></div>

<p>Algorithm: The normal vectors are calculated by taking the cross product
of the diagonals of each of the quadrilaterals in the meshgrid to find the
normal vectors of the centers of these quadrilaterals.  The four nearest
normal vectors to the meshgrid points are then averaged to obtain the
normal to the surface at the meshgridded points.
</p>

<p><strong>See also:</strong> <a href="#XREFisonormals">isonormals</a>, <a href="Two_002dDimensional-Plots.html#XREFquiver3">quiver3</a>, <a href="#XREFsurf">surf</a>, <a href="#XREFmeshgrid">meshgrid</a>.
</p></dd></dl>


<a name="XREFisosurface"></a><dl>
<dt><a name="index-isosurface"></a>Function File: <em>[<var>fv</var>] =</em> <strong>isosurface</strong> <em>(<var>val</var>, <var>iso</var>)</em></dt>
<dt><a name="index-isosurface-1"></a>Function File: <em>[<var>fv</var>] =</em> <strong>isosurface</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>val</var>, <var>iso</var>)</em></dt>
<dt><a name="index-isosurface-2"></a>Function File: <em>[<var>fv</var>] =</em> <strong>isosurface</strong> <em>(&hellip;, &quot;noshare&quot;, &quot;verbose&quot;)</em></dt>
<dt><a name="index-isosurface-3"></a>Function File: <em>[<var>fvc</var>] =</em> <strong>isosurface</strong> <em>(&hellip;, <var>col</var>)</em></dt>
<dt><a name="index-isosurface-4"></a>Function File: <em>[<var>f</var>, <var>v</var>] =</em> <strong>isosurface</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>val</var>, <var>iso</var>)</em></dt>
<dt><a name="index-isosurface-5"></a>Function File: <em>[<var>f</var>, <var>v</var>, <var>c</var>] =</em> <strong>isosurface</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>val</var>, <var>iso</var>, <var>col</var>)</em></dt>
<dt><a name="index-isosurface-6"></a>Function File: <em></em> <strong>isosurface</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>val</var>, <var>iso</var>, <var>col</var>, <var>opt</var>)</em></dt>
<dd>
<p>Calculate isosurface of 3-D data.
</p>
<p>If called with one output argument and the first input argument
<var>val</var> is a three-dimensional array that contains the data of an
isosurface geometry and the second input argument <var>iso</var> keeps the
isovalue as a scalar value then return a structure array <var>fv</var>
that contains the fields <var>Faces</var> and <var>Vertices</var> at computed
points <code>[x, y, z] = meshgrid (1:l, 1:m, 1:n)</code>.  The output
argument <var>fv</var> can directly be taken as an input argument for the
<code>patch</code> function.
</p>
<p>If called with further input arguments <var>x</var>, <var>y</var> and <var>z</var>
which are three&ndash;dimensional arrays with the same size than <var>val</var>
then the volume data is taken at those given points.
</p>
<p>The string input argument <code>&quot;noshare&quot;</code> is only for compatibility and
has no effect.  If given the string input argument
<code>&quot;verbose&quot;</code> then print messages to the command line interface about the
current progress.
</p>
<p>If called with the input argument <var>col</var> which is a
three-dimensional array of the same size than <var>val</var> then take
those values for the interpolation of coloring the isosurface
geometry.  Add the field <var>FaceVertexCData</var> to the structure
array <var>fv</var>.
</p>
<p>If called with two or three output arguments then return the
information about the faces <var>f</var>, vertices <var>v</var> and color data
<var>c</var> as separate arrays instead of a single structure array.
</p>
<p>If called with no output argument then directly process the
isosurface geometry with the <code>patch</code> command.
</p>
<p>For example,
</p>
<div class="example">
<pre class="example">[x, y, z] = meshgrid (1:5, 1:5, 1:5);
val = rand (5, 5, 5);
isosurface (x, y, z, val, .5);
</pre></div>

<p>will directly draw a random isosurface geometry in a graphics window.
Another example for an isosurface geometry with different additional
coloring
</p>
<div class="smallexample">
<pre class="smallexample">N = 15;    # Increase number of vertices in each direction
iso = .4;  # Change isovalue to .1 to display a sphere
lin = linspace (0, 2, N);
[x, y, z] = meshgrid (lin, lin, lin);
c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
figure (); # Open another figure window

subplot (2,2,1); view (-38, 20);
[f, v] = isosurface (x, y, z, c, iso);
p = patch (&quot;Faces&quot;, f, &quot;Vertices&quot;, v, &quot;EdgeColor&quot;, &quot;none&quot;);
set (gca, &quot;PlotBoxAspectRatioMode&quot;, &quot;manual&quot;, ...
          &quot;PlotBoxAspectRatio&quot;, [1 1 1]);
# set (p, &quot;FaceColor&quot;, &quot;green&quot;, &quot;FaceLighting&quot;, &quot;phong&quot;);
# light (&quot;Position&quot;, [1 1 5]); # Available with the JHandles package

subplot (2,2,2); view (-38, 20);
p = patch (&quot;Faces&quot;, f, &quot;Vertices&quot;, v, &quot;EdgeColor&quot;, &quot;blue&quot;);
set (gca, &quot;PlotBoxAspectRatioMode&quot;, &quot;manual&quot;, ...
          &quot;PlotBoxAspectRatio&quot;, [1 1 1]);
# set (p, &quot;FaceColor&quot;, &quot;none&quot;, &quot;FaceLighting&quot;, &quot;phong&quot;);
# light (&quot;Position&quot;, [1 1 5]);

subplot (2,2,3); view (-38, 20);
[f, v, c] = isosurface (x, y, z, c, iso, y);
p = patch (&quot;Faces&quot;, f, &quot;Vertices&quot;, v, &quot;FaceVertexCData&quot;, c, ...
           &quot;FaceColor&quot;, &quot;interp&quot;, &quot;EdgeColor&quot;, &quot;none&quot;);
set (gca, &quot;PlotBoxAspectRatioMode&quot;, &quot;manual&quot;, ...
          &quot;PlotBoxAspectRatio&quot;, [1 1 1]);
# set (p, &quot;FaceLighting&quot;, &quot;phong&quot;);
# light (&quot;Position&quot;, [1 1 5]);

subplot (2,2,4); view (-38, 20);
p = patch (&quot;Faces&quot;, f, &quot;Vertices&quot;, v, &quot;FaceVertexCData&quot;, c, ...
           &quot;FaceColor&quot;, &quot;interp&quot;, &quot;EdgeColor&quot;, &quot;blue&quot;);
set (gca, &quot;PlotBoxAspectRatioMode&quot;, &quot;manual&quot;, ...
          &quot;PlotBoxAspectRatio&quot;, [1 1 1]);
# set (p, &quot;FaceLighting&quot;, &quot;phong&quot;);
# light (&quot;Position&quot;, [1 1 5]);
</pre></div>


<p><strong>See also:</strong> <a href="#XREFisonormals">isonormals</a>, <a href="#XREFisocolors">isocolors</a>.
</p></dd></dl>


<a name="XREFisonormals"></a><dl>
<dt><a name="index-isonormals"></a>Function File: <em>[<var>n</var>] =</em> <strong>isonormals</strong> <em>(<var>val</var>, <var>v</var>)</em></dt>
<dt><a name="index-isonormals-1"></a>Function File: <em>[<var>n</var>] =</em> <strong>isonormals</strong> <em>(<var>val</var>, <var>p</var>)</em></dt>
<dt><a name="index-isonormals-2"></a>Function File: <em>[<var>n</var>] =</em> <strong>isonormals</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>val</var>, <var>v</var>)</em></dt>
<dt><a name="index-isonormals-3"></a>Function File: <em>[<var>n</var>] =</em> <strong>isonormals</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>val</var>, <var>p</var>)</em></dt>
<dt><a name="index-isonormals-4"></a>Function File: <em>[<var>n</var>] =</em> <strong>isonormals</strong> <em>(&hellip;, &quot;negate&quot;)</em></dt>
<dt><a name="index-isonormals-5"></a>Function File: <em></em> <strong>isonormals</strong> <em>(&hellip;, <var>p</var>)</em></dt>
<dd>
<p>Calculate normals to an isosurface.
</p>
<p>If called with one output argument and the first input argument
<var>val</var> is a three-dimensional array that contains the data for an
isosurface geometry and the second input argument <var>v</var> keeps the
vertices of an isosurface then return the normals <var>n</var> in form of
a matrix with the same size than <var>v</var> at computed points
<code>[x, y, z] = meshgrid (1:l, 1:m, 1:n)</code>.  The output argument
<var>n</var> can be taken to manually set <var>VertexNormals</var> of a patch.
</p>
<p>If called with further input arguments <var>x</var>, <var>y</var> and <var>z</var>
which are three&ndash;dimensional arrays with the same size than <var>val</var>
then the volume data is taken at those given points.  Instead of the
vertices data <var>v</var> a patch handle <var>p</var> can be passed to this
function.
</p>
<p>If given the string input argument <code>&quot;negate&quot;</code> as last input argument
then compute the reverse vector normals of an isosurface geometry.
</p>
<p>If no output argument is given then directly redraw the patch that is
given by the patch handle <var>p</var>.
</p>
<p>For example:
</p>
<div class="smallexample">
<pre class="smallexample">function [] = isofinish (p)
  set (gca, &quot;PlotBoxAspectRatioMode&quot;, &quot;manual&quot;, ...
            &quot;PlotBoxAspectRatio&quot;, [1 1 1]);
  set (p, &quot;VertexNormals&quot;, -get (p,&quot;VertexNormals&quot;)); # Revert normals
  set (p, &quot;FaceColor&quot;, &quot;interp&quot;);
  ## set (p, &quot;FaceLighting&quot;, &quot;phong&quot;);
  ## light (&quot;Position&quot;, [1 1 5]); # Available with JHandles
endfunction

N = 15;    # Increase number of vertices in each direction
iso = .4;  # Change isovalue to .1 to display a sphere
lin = linspace (0, 2, N);
[x, y, z] = meshgrid (lin, lin, lin);
c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
figure (); # Open another figure window

subplot (2,2,1); view (-38, 20);
[f, v, cdat] = isosurface (x, y, z, c, iso, y);
p = patch (&quot;Faces&quot;, f, &quot;Vertices&quot;, v, &quot;FaceVertexCData&quot;, cdat, ...
           &quot;FaceColor&quot;, &quot;interp&quot;, &quot;EdgeColor&quot;, &quot;none&quot;);
isofinish (p);  # Call user function isofinish

subplot (2,2,2); view (-38, 20);
p = patch (&quot;Faces&quot;, f, &quot;Vertices&quot;, v, &quot;FaceVertexCData&quot;, cdat, ...
           &quot;FaceColor&quot;, &quot;interp&quot;, &quot;EdgeColor&quot;, &quot;none&quot;);
isonormals (x, y, z, c, p); # Directly modify patch
isofinish (p);

subplot (2,2,3); view (-38, 20);
p = patch (&quot;Faces&quot;, f, &quot;Vertices&quot;, v, &quot;FaceVertexCData&quot;, cdat, ...
           &quot;FaceColor&quot;, &quot;interp&quot;, &quot;EdgeColor&quot;, &quot;none&quot;);
n = isonormals (x, y, z, c, v); # Compute normals of isosurface
set (p, &quot;VertexNormals&quot;, n);    # Manually set vertex normals
isofinish (p);

subplot (2,2,4); view (-38, 20);
p = patch (&quot;Faces&quot;, f, &quot;Vertices&quot;, v, &quot;FaceVertexCData&quot;, cdat, ...
           &quot;FaceColor&quot;, &quot;interp&quot;, &quot;EdgeColor&quot;, &quot;none&quot;);
isonormals (x, y, z, c, v, &quot;negate&quot;); # Use reverse directly
isofinish (p);
</pre></div>


<p><strong>See also:</strong> <a href="#XREFisosurface">isosurface</a>, <a href="#XREFisocolors">isocolors</a>.
</p></dd></dl>


<a name="XREFisocolors"></a><dl>
<dt><a name="index-isocolors"></a>Function File: <em>[<var>cd</var>] =</em> <strong>isocolors</strong> <em>(<var>c</var>, <var>v</var>)</em></dt>
<dt><a name="index-isocolors-1"></a>Function File: <em>[<var>cd</var>] =</em> <strong>isocolors</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>c</var>, <var>v</var>)</em></dt>
<dt><a name="index-isocolors-2"></a>Function File: <em>[<var>cd</var>] =</em> <strong>isocolors</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>r</var>, <var>g</var>, <var>b</var>, <var>v</var>)</em></dt>
<dt><a name="index-isocolors-3"></a>Function File: <em>[<var>cd</var>] =</em> <strong>isocolors</strong> <em>(<var>r</var>, <var>g</var>, <var>b</var>, <var>v</var>)</em></dt>
<dt><a name="index-isocolors-4"></a>Function File: <em>[<var>cd</var>] =</em> <strong>isocolors</strong> <em>(&hellip;, <var>p</var>)</em></dt>
<dt><a name="index-isocolors-5"></a>Function File: <em></em> <strong>isocolors</strong> <em>(&hellip;)</em></dt>
<dd>
<p>Compute isosurface colors.
</p>
<p>If called with one output argument and the first input argument
<var>c</var> is a three-dimensional array that contains color values and
the second input argument <var>v</var> keeps the vertices of a geometry
then return a matrix <var>cd</var> with color data information for the
geometry at computed points
<code>[x, y, z] = meshgrid (1:l, 1:m, 1:n)</code>.  The output argument
<var>cd</var> can be taken to manually set FaceVertexCData of a patch.
</p>
<p>If called with further input arguments <var>x</var>, <var>y</var> and <var>z</var>
which are three&ndash;dimensional arrays of the same size than <var>c</var>
then the color data is taken at those given points.  Instead of the
color data <var>c</var> this function can also be called with RGB values
<var>r</var>, <var>g</var>, <var>b</var>.  If input argumnets <var>x</var>, <var>y</var>,
<var>z</var> are not given then again <code>meshgrid</code> computed values
are taken.
</p>
<p>Optionally, the patch handle <var>p</var> can be given as the last input
argument to all variations of function calls instead of the vertices
data <var>v</var>.  Finally, if no output argument is given then directly
change the colors of a patch that is given by the patch handle
<var>p</var>.
</p>
<p>For example:
</p>
<div class="example">
<pre class="example">function [] = isofinish (p)
  set (gca, &quot;PlotBoxAspectRatioMode&quot;, &quot;manual&quot;, ...
            &quot;PlotBoxAspectRatio&quot;, [1 1 1]);
  set (p, &quot;FaceColor&quot;, &quot;interp&quot;);
  ## set (p, &quot;FaceLighting&quot;, &quot;flat&quot;);
  ## light (&quot;Position&quot;, [1 1 5]);  # Available with JHandles
endfunction

N = 15;    # Increase number of vertices in each direction
iso = .4;  # Change isovalue to .1 to display a sphere
lin = linspace (0, 2, N);
[x, y, z] = meshgrid (lin, lin, lin);
c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
figure (); # Open another figure window

subplot (2,2,1); view (-38, 20);
[f, v] = isosurface (x, y, z, c, iso);
p = patch (&quot;Faces&quot;, f, &quot;Vertices&quot;, v, &quot;EdgeColor&quot;, &quot;none&quot;);
cdat = rand (size (c));       # Compute random patch color data
isocolors (x, y, z, cdat, p); # Directly set colors of patch
isofinish (p);                # Call user function isofinish

subplot (2,2,2); view (-38, 20);
p = patch (&quot;Faces&quot;, f, &quot;Vertices&quot;, v, &quot;EdgeColor&quot;, &quot;none&quot;);
[r, g, b] = meshgrid (lin, 2-lin, 2-lin);
cdat = isocolors (x, y, z, c, v); # Compute color data vertices
set (p, &quot;FaceVertexCData&quot;, cdat); # Set color data manually
isofinish (p);

subplot (2,2,3); view (-38, 20);
p = patch (&quot;Faces&quot;, f, &quot;Vertices&quot;, v, &quot;EdgeColor&quot;, &quot;none&quot;);
cdat = isocolors (r, g, b, c, p); # Compute color data patch
set (p, &quot;FaceVertexCData&quot;, cdat); # Set color data manually
isofinish (p);

subplot (2,2,4); view (-38, 20);
p = patch (&quot;Faces&quot;, f, &quot;Vertices&quot;, v, &quot;EdgeColor&quot;, &quot;none&quot;);
r = g = b = repmat ([1:N] / N, [N, 1, N]); # Black to white
cdat = isocolors (x, y, z, r, g, b, v);
set (p, &quot;FaceVertexCData&quot;, cdat);
isofinish (p);
</pre></div>


<p><strong>See also:</strong> <a href="#XREFisosurface">isosurface</a>, <a href="#XREFisonormals">isonormals</a>.
</p></dd></dl>


<a name="XREFshrinkfaces"></a><dl>
<dt><a name="index-shrinkfaces"></a>Function File: <em></em> <strong>shrinkfaces</strong> <em>(<var>p</var>, <var>sf</var>)</em></dt>
<dt><a name="index-shrinkfaces-1"></a>Function File: <em><var>nfv</var> =</em> <strong>shrinkfaces</strong> <em>(<var>p</var>, <var>sf</var>)</em></dt>
<dt><a name="index-shrinkfaces-2"></a>Function File: <em><var>nfv</var> =</em> <strong>shrinkfaces</strong> <em>(<var>fv</var>, <var>sf</var>)</em></dt>
<dt><a name="index-shrinkfaces-3"></a>Function File: <em><var>nfv</var> =</em> <strong>shrinkfaces</strong> <em>(<var>f</var>, <var>v</var>, <var>sf</var>)</em></dt>
<dt><a name="index-shrinkfaces-4"></a>Function File: <em>[<var>nf</var>, <var>nv</var>] =</em> <strong>shrinkfaces</strong> <em>(&hellip;)</em></dt>
<dd>
<p>Reduce the size of faces in a patch by the shrink factor <var>sf</var>.
</p>
<p>The patch object can be specified by a graphics handle (<var>p</var>), a patch
structure (<var>fv</var>) with the fields <code>&quot;faces&quot;</code> and <code>&quot;vertices&quot;</code>,
or as two separate matrices (<var>f</var>, <var>v</var>) of faces and vertices.
</p>
<p>The shrink factor <var>sf</var> is a positive number specifying the percentage
of the original area the new face will occupy.  If no factor is given the
default is 0.3 (a reduction to 30% of the original size).  A factor greater
than 1.0 will result in the expansion of faces.
</p>
<p>Given a patch handle as the first input argument and no output parameters,
perform the shrinking of the patch faces in place and redraw the patch.
</p>
<p>If called with one output argument, return a structure with fields
<code>&quot;faces&quot;</code>, <code>&quot;vertices&quot;</code>, and <code>&quot;facevertexcdata&quot;</code>
containing the data after shrinking.  This structure can be used directly
as an input argument to the <code>patch</code> function.
</p>
<p><strong>Caution:</strong>: Performing the shrink operation on faces which are not
convex can lead to undesirable results.
</p>
<p>Example: a triangulated 3/4 circle and the corresponding shrunken version.
</p>
<div class="example">
<pre class="example">[phi r] = meshgrid (linspace (0, 1.5*pi, 16), linspace (1, 2, 4));
tri = delaunay (phi(:), r(:));
v = [r(:).*sin(phi(:)) r(:).*cos(phi(:))];
clf ()
p = patch (&quot;Faces&quot;, tri, &quot;Vertices&quot;, v, &quot;FaceColor&quot;, &quot;none&quot;);
fv = shrinkfaces (p);
patch (fv)
axis equal
grid on
</pre></div>


<p><strong>See also:</strong> <a href="Graphics-Objects.html#XREFpatch">patch</a>.
</p></dd></dl>


<a name="XREFdiffuse"></a><dl>
<dt><a name="index-diffuse"></a>Function File: <em></em> <strong>diffuse</strong> <em>(<var>sx</var>, <var>sy</var>, <var>sz</var>, <var>lv</var>)</em></dt>
<dd><p>Calculate the diffuse reflection strength of a surface defined by the normal
vector elements <var>sx</var>, <var>sy</var>, <var>sz</var>.
</p>
<p>The light source location vector <var>lv</var> can be given as a 2-element vector
[azimuth, elevation] in degrees or as a 3-element vector [x, y, z].
</p>
<p><strong>See also:</strong> <a href="#XREFspecular">specular</a>, <a href="#XREFsurfl">surfl</a>.
</p></dd></dl>


<a name="XREFspecular"></a><dl>
<dt><a name="index-specular"></a>Function File: <em></em> <strong>specular</strong> <em>(<var>sx</var>, <var>sy</var>, <var>sz</var>, <var>lv</var>, <var>vv</var>)</em></dt>
<dt><a name="index-specular-1"></a>Function File: <em></em> <strong>specular</strong> <em>(<var>sx</var>, <var>sy</var>, <var>sz</var>, <var>lv</var>, <var>vv</var>, <var>se</var>)</em></dt>
<dd><p>Calculate the specular reflection strength of a surface defined by the
normal vector elements <var>sx</var>, <var>sy</var>, <var>sz</var> using Phong&rsquo;s
approximation.
</p>
<p>The light source location and viewer location vectors are specified using
parameters <var>lv</var> and <var>vv</var> respectively.  The location vectors can
given as 2-element vectors [azimuth, elevation] in degrees or as 3-element
vectors [x, y, z].
</p>
<p>An optional sixth argument specifies the specular exponent (spread) <var>se</var>.
If not given, <var>se</var> defaults to 10.
</p>
<p><strong>See also:</strong> <a href="#XREFdiffuse">diffuse</a>, <a href="#XREFsurfl">surfl</a>.
</p></dd></dl>


<a name="XREFmeshgrid"></a><dl>
<dt><a name="index-meshgrid"></a>Function File: <em>[<var>xx</var>, <var>yy</var>] =</em> <strong>meshgrid</strong> <em>(<var>x</var>, <var>y</var>)</em></dt>
<dt><a name="index-meshgrid-1"></a>Function File: <em>[<var>xx</var>, <var>yy</var>, <var>zz</var>] =</em> <strong>meshgrid</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>)</em></dt>
<dt><a name="index-meshgrid-2"></a>Function File: <em>[<var>xx</var>, <var>yy</var>] =</em> <strong>meshgrid</strong> <em>(<var>x</var>)</em></dt>
<dt><a name="index-meshgrid-3"></a>Function File: <em>[<var>xx</var>, <var>yy</var>, <var>zz</var>] =</em> <strong>meshgrid</strong> <em>(<var>x</var>)</em></dt>
<dd><p>Given vectors of <var>x</var> and <var>y</var> coordinates, return matrices <var>xx</var>
and <var>yy</var> corresponding to a full 2-D grid.
</p>
<p>The rows of <var>xx</var> are copies of <var>x</var>, and the columns of <var>yy</var> are
copies of <var>y</var>.  If <var>y</var> is omitted, then it is assumed to be the same
as <var>x</var>.
</p>
<p>If the optional <var>z</var> input is given, or <var>zz</var> is requested, then the
output will be a full 3-D grid.
</p>
<p><code>meshgrid</code> is most frequently used to produce input for a 2-D or 3-D
function that will be plotted.  The following example creates a surface
plot of the &ldquo;sombrero&rdquo; function.
</p>
<div class="example">
<pre class="example">f = @(x,y) sin (sqrt (x.^2 + y.^2)) ./ sqrt (x.^2 + y.^2);
range = linspace (-8, 8, 41);
[<var>X</var>, <var>Y</var>] = meshgrid (range, range);
Z = f (X, Y);
surf (X, Y, Z);
</pre></div>

<p>Programming Note: <code>meshgrid</code> is restricted to 2-D or 3-D grid
generation.  The <code>ndgrid</code> function will generate 1-D through N-D
grids.  However, the functions are not completely equivalent.  If <var>x</var>
is a vector of length M and <var>y</var> is a vector of length N, then
<code>meshgrid</code> will produce an output grid which is NxM.  <code>ndgrid</code>
will produce an output which is MxN (transpose) for the same
input.  Some core functions expect <code>meshgrid</code> input and others expect
<code>ndgrid</code> input.  Check the documentation for the function in question
to determine the proper input format.
</p>
<p><strong>See also:</strong> <a href="#XREFndgrid">ndgrid</a>, <a href="#XREFmesh">mesh</a>, <a href="Two_002dDimensional-Plots.html#XREFcontour">contour</a>, <a href="#XREFsurf">surf</a>.
</p></dd></dl>


<a name="XREFndgrid"></a><dl>
<dt><a name="index-ndgrid"></a>Function File: <em>[<var>y1</var>, <var>y2</var>, &hellip;, <var>y</var>n] =</em> <strong>ndgrid</strong> <em>(<var>x1</var>, <var>x2</var>, &hellip;, <var>x</var>n)</em></dt>
<dt><a name="index-ndgrid-1"></a>Function File: <em>[<var>y1</var>, <var>y2</var>, &hellip;, <var>y</var>n] =</em> <strong>ndgrid</strong> <em>(<var>x</var>)</em></dt>
<dd><p>Given n vectors <var>x1</var>, &hellip;, <var>x</var>n, <code>ndgrid</code> returns n
arrays of dimension n.
</p>
<p>The elements of the i-th output argument contains the elements of the
vector <var>x</var>i repeated over all dimensions different from the i-th
dimension.  Calling ndgrid with only one input argument <var>x</var> is
equivalent to calling ndgrid with all n input arguments equal to <var>x</var>:
</p>
<p>[<var>y1</var>, <var>y2</var>, &hellip;, <var>y</var>n] = ndgrid (<var>x</var>, &hellip;, <var>x</var>)
</p>
<p>Programming Note: <code>ndgrid</code> is very similar to the function
<code>meshgrid</code> except that the first two dimensions are transposed in
comparison to <code>meshgrid</code>.  Some core functions expect <code>meshgrid</code>
input and others expect <code>ndgrid</code> input.  Check the documentation for
the function in question to determine the proper input format.
</p>
<p><strong>See also:</strong> <a href="#XREFmeshgrid">meshgrid</a>.
</p></dd></dl>


<a name="XREFplot3"></a><dl>
<dt><a name="index-plot3"></a>Function File: <em></em> <strong>plot3</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>)</em></dt>
<dt><a name="index-plot3-1"></a>Function File: <em></em> <strong>plot3</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>prop</var>, <var>value</var>, &hellip;)</em></dt>
<dt><a name="index-plot3-2"></a>Function File: <em></em> <strong>plot3</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>fmt</var>)</em></dt>
<dt><a name="index-plot3-3"></a>Function File: <em></em> <strong>plot3</strong> <em>(<var>x</var>, <var>cplx</var>)</em></dt>
<dt><a name="index-plot3-4"></a>Function File: <em></em> <strong>plot3</strong> <em>(<var>cplx</var>)</em></dt>
<dt><a name="index-plot3-5"></a>Function File: <em></em> <strong>plot3</strong> <em>(<var>hax</var>, &hellip;)</em></dt>
<dt><a name="index-plot3-6"></a>Function File: <em><var>h</var> =</em> <strong>plot3</strong> <em>(&hellip;)</em></dt>
<dd><p>Produce 3-D plots.
</p>
<p>Many different combinations of arguments are possible.  The simplest
form is
</p>
<div class="example">
<pre class="example">plot3 (<var>x</var>, <var>y</var>, <var>z</var>)
</pre></div>

<p>in which the arguments are taken to be the vertices of the points to
be plotted in three dimensions.  If all arguments are vectors of the
same length, then a single continuous line is drawn.  If all arguments
are matrices, then each column of is treated as a separate line.  No attempt
is made to transpose the arguments to make the number of rows match.
</p>
<p>If only two arguments are given, as
</p>
<div class="example">
<pre class="example">plot3 (<var>x</var>, <var>cplx</var>)
</pre></div>

<p>the real and imaginary parts of the second argument are used
as the <var>y</var> and <var>z</var> coordinates, respectively.
</p>
<p>If only one argument is given, as
</p>
<div class="example">
<pre class="example">plot3 (<var>cplx</var>)
</pre></div>

<p>the real and imaginary parts of the argument are used as the <var>y</var>
and <var>z</var> values, and they are plotted versus their index.
</p>
<p>Arguments may also be given in groups of three as
</p>
<div class="example">
<pre class="example">plot3 (<var>x1</var>, <var>y1</var>, <var>z1</var>, <var>x2</var>, <var>y2</var>, <var>z2</var>, &hellip;)
</pre></div>

<p>in which each set of three arguments is treated as a separate line or
set of lines in three dimensions.
</p>
<p>To plot multiple one- or two-argument groups, separate each group
with an empty format string, as
</p>
<div class="example">
<pre class="example">plot3 (<var>x1</var>, <var>c1</var>, &quot;&quot;, <var>c2</var>, &quot;&quot;, &hellip;)
</pre></div>

<p>Multiple property-value pairs may be specified which will affect the line
objects drawn by <code>plot3</code>.  If the <var>fmt</var> argument is supplied it
will format the line objects in the same manner as <code>plot</code>.
</p>
<p>If the first argument <var>hax</var> is an axes handle, then plot into this axis,
rather than the current axes returned by <code>gca</code>.
</p>
<p>The optional return value <var>h</var> is a graphics handle to the created plot.
</p>
<p>Example:
</p>
<div class="example">
<pre class="example">z = [0:0.05:5];
plot3 (cos (2*pi*z), sin (2*pi*z), z, &quot;;helix;&quot;);
plot3 (z, exp (2i*pi*z), &quot;;complex sinusoid;&quot;);
</pre></div>

<p><strong>See also:</strong> <a href="Three_002ddimensional-Function-Plotting.html#XREFezplot3">ezplot3</a>, <a href="Two_002dDimensional-Plots.html#XREFplot">plot</a>.
</p></dd></dl>


<a name="XREFview"></a><dl>
<dt><a name="index-view"></a>Function File: <em></em> <strong>view</strong> <em>(<var>azimuth</var>, <var>elevation</var>)</em></dt>
<dt><a name="index-view-1"></a>Function File: <em></em> <strong>view</strong> <em>([<var>azimuth</var> <var>elevation</var>])</em></dt>
<dt><a name="index-view-2"></a>Function File: <em></em> <strong>view</strong> <em>([<var>x</var> <var>y</var> <var>z</var>])</em></dt>
<dt><a name="index-view-3"></a>Function File: <em></em> <strong>view</strong> <em>(2)</em></dt>
<dt><a name="index-view-4"></a>Function File: <em></em> <strong>view</strong> <em>(3)</em></dt>
<dt><a name="index-view-5"></a>Function File: <em></em> <strong>view</strong> <em>(<var>hax</var>, &hellip;)</em></dt>
<dt><a name="index-view-6"></a>Function File: <em>[<var>azimuth</var>, <var>elevation</var>] =</em> <strong>view</strong> <em>()</em></dt>
<dd><p>Query or set the viewpoint for the current axes.
</p>
<p>The parameters <var>azimuth</var> and <var>elevation</var> can be given as two
arguments or as 2-element vector.  The viewpoint can also be specified with
Cartesian coordinates <var>x</var>, <var>y</var>, and <var>z</var>.
</p>
<p>The call <code>view (2)</code> sets the viewpoint to <var>azimuth</var>&nbsp;=&nbsp;0<!-- /@w -->
and <var>elevation</var>&nbsp;=&nbsp;90<!-- /@w -->, which is the default for 2-D graphs.
</p>
<p>The call <code>view (3)</code> sets the viewpoint to <var>azimuth</var>&nbsp;=&nbsp;<span class="nolinebreak">-37.5</span><!-- /@w -->
and <var>elevation</var>&nbsp;=&nbsp;30<!-- /@w -->, which is the default for 3-D graphs.
</p>
<p>If the first argument <var>hax</var> is an axes handle, then operate on
this axis rather than the current axes returned by <code>gca</code>.
</p>
<p>If no inputs are given, return the current <var>azimuth</var> and <var>elevation</var>.
</p></dd></dl>


<a name="XREFslice"></a><dl>
<dt><a name="index-slice"></a>Function File: <em></em> <strong>slice</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>v</var>, <var>sx</var>, <var>sy</var>, <var>sz</var>)</em></dt>
<dt><a name="index-slice-1"></a>Function File: <em></em> <strong>slice</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>v</var>, <var>xi</var>, <var>yi</var>, <var>zi</var>)</em></dt>
<dt><a name="index-slice-2"></a>Function File: <em></em> <strong>slice</strong> <em>(<var>v</var>, <var>sx</var>, <var>sy</var>, <var>sz</var>)</em></dt>
<dt><a name="index-slice-3"></a>Function File: <em></em> <strong>slice</strong> <em>(<var>v</var>, <var>xi</var>, <var>yi</var>, <var>zi</var>)</em></dt>
<dt><a name="index-slice-4"></a>Function File: <em></em> <strong>slice</strong> <em>(&hellip;, <var>method</var>)</em></dt>
<dt><a name="index-slice-5"></a>Function File: <em></em> <strong>slice</strong> <em>(<var>hax</var>, &hellip;)</em></dt>
<dt><a name="index-slice-6"></a>Function File: <em><var>h</var> =</em> <strong>slice</strong> <em>(&hellip;)</em></dt>
<dd><p>Plot slices of 3-D data/scalar fields.
</p>
<p>Each element of the 3-dimensional array <var>v</var> represents a scalar value at
a location given by the parameters <var>x</var>, <var>y</var>, and <var>z</var>.  The
parameters <var>x</var>, <var>x</var>, and <var>z</var> are either 3-dimensional arrays of
the same size as the array <var>v</var> in the <code>&quot;meshgrid&quot;</code> format or
vectors.  The parameters <var>xi</var>, etc. respect a similar format to
<var>x</var>, etc., and they represent the points at which the array <var>vi</var>
is interpolated using interp3.  The vectors <var>sx</var>, <var>sy</var>, and
<var>sz</var> contain points of orthogonal slices of the respective axes.
</p>
<p>If <var>x</var>, <var>y</var>, <var>z</var> are omitted, they are assumed to be
<code>x = 1:size (<var>v</var>, 2)</code>, <code>y = 1:size (<var>v</var>, 1)</code> and
<code>z = 1:size (<var>v</var>, 3)</code>.
</p>
<p><var>method</var> is one of:
</p>
<dl compact="compact">
<dt><code>&quot;nearest&quot;</code></dt>
<dd><p>Return the nearest neighbor.
</p>
</dd>
<dt><code>&quot;linear&quot;</code></dt>
<dd><p>Linear interpolation from nearest neighbors.
</p>
</dd>
<dt><code>&quot;cubic&quot;</code></dt>
<dd><p>Cubic interpolation from four nearest neighbors (not implemented yet).
</p>
</dd>
<dt><code>&quot;spline&quot;</code></dt>
<dd><p>Cubic spline interpolation&mdash;smooth first and second derivatives
throughout the curve.
</p></dd>
</dl>

<p>The default method is <code>&quot;linear&quot;</code>.
</p>
<p>If the first argument <var>hax</var> is an axes handle, then plot into this axis,
rather than the current axes returned by <code>gca</code>.
</p>
<p>The optional return value <var>h</var> is a graphics handle to the created
surface object.
</p>
<p>Examples:
</p>
<div class="example">
<pre class="example">[x, y, z] = meshgrid (linspace (-8, 8, 32));
v = sin (sqrt (x.^2 + y.^2 + z.^2)) ./ (sqrt (x.^2 + y.^2 + z.^2));
slice (x, y, z, v, [], 0, []);

[xi, yi] = meshgrid (linspace (-7, 7));
zi = xi + yi;
slice (x, y, z, v, xi, yi, zi);
</pre></div>

<p><strong>See also:</strong> <a href="Multi_002ddimensional-Interpolation.html#XREFinterp3">interp3</a>, <a href="Graphics-Objects.html#XREFsurface">surface</a>, <a href="Two_002dDimensional-Plots.html#XREFpcolor">pcolor</a>.
</p></dd></dl>


<a name="XREFribbon"></a><dl>
<dt><a name="index-ribbon"></a>Function File: <em></em> <strong>ribbon</strong> <em>(<var>y</var>)</em></dt>
<dt><a name="index-ribbon-1"></a>Function File: <em></em> <strong>ribbon</strong> <em>(<var>x</var>, <var>y</var>)</em></dt>
<dt><a name="index-ribbon-2"></a>Function File: <em></em> <strong>ribbon</strong> <em>(<var>x</var>, <var>y</var>, <var>width</var>)</em></dt>
<dt><a name="index-ribbon-3"></a>Function File: <em></em> <strong>ribbon</strong> <em>(<var>hax</var>, &hellip;)</em></dt>
<dt><a name="index-ribbon-4"></a>Function File: <em><var>h</var> =</em> <strong>ribbon</strong> <em>(&hellip;)</em></dt>
<dd><p>Draw a ribbon plot for the columns of <var>y</var> vs. <var>x</var>.
</p>
<p>The optional parameter <var>width</var> specifies the width of a single ribbon
(default is 0.75).  If <var>x</var> is omitted, a vector containing the
row numbers is assumed (<code>1:rows (Y)</code>).
</p>
<p>If the first argument <var>hax</var> is an axes handle, then plot into this axis,
rather than the current axes returned by <code>gca</code>.
</p>
<p>The optional return value <var>h</var> is a vector of graphics handles to
the surface objects representing each ribbon.
</p>
<p><strong>See also:</strong> <a href="Graphics-Objects.html#XREFsurface">surface</a>, <a href="#XREFwaterfall">waterfall</a>.
</p></dd></dl>


<a name="XREFshading"></a><dl>
<dt><a name="index-shading"></a>Function File: <em></em> <strong>shading</strong> <em>(<var>type</var>)</em></dt>
<dt><a name="index-shading-1"></a>Function File: <em></em> <strong>shading</strong> <em>(<var>hax</var>, <var>type</var>)</em></dt>
<dd><p>Set the shading of patch or surface graphic objects.
</p>
<p>Valid arguments for <var>type</var> are
</p>
<dl compact="compact">
<dt><code>&quot;flat&quot;</code></dt>
<dd><p>Single colored patches with invisible edges.
</p>
</dd>
<dt><code>&quot;faceted&quot;</code></dt>
<dd><p>Single colored patches with visible edges.
</p>
</dd>
<dt><code>&quot;interp&quot;</code></dt>
<dd><p>Color between patch vertices are interpolated and the patch edges are
invisible.
</p></dd>
</dl>

<p>If the first argument <var>hax</var> is an axes handle, then plot into this axis,
rather than the current axes returned by <code>gca</code>.
</p>
<p><strong>See also:</strong> <a href="Two_002dDimensional-Plots.html#XREFfill">fill</a>, <a href="#XREFmesh">mesh</a>, <a href="Graphics-Objects.html#XREFpatch">patch</a>, <a href="Two_002dDimensional-Plots.html#XREFpcolor">pcolor</a>, <a href="#XREFsurf">surf</a>, <a href="Graphics-Objects.html#XREFsurface">surface</a>, <a href="#XREFhidden">hidden</a>.
</p></dd></dl>


<a name="XREFscatter3"></a><dl>
<dt><a name="index-scatter3"></a>Function File: <em></em> <strong>scatter3</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>)</em></dt>
<dt><a name="index-scatter3-1"></a>Function File: <em></em> <strong>scatter3</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>s</var>)</em></dt>
<dt><a name="index-scatter3-2"></a>Function File: <em></em> <strong>scatter3</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>s</var>, <var>c</var>)</em></dt>
<dt><a name="index-scatter3-3"></a>Function File: <em></em> <strong>scatter3</strong> <em>(&hellip;, <var>style</var>)</em></dt>
<dt><a name="index-scatter3-4"></a>Function File: <em></em> <strong>scatter3</strong> <em>(&hellip;, &quot;filled&quot;)</em></dt>
<dt><a name="index-scatter3-5"></a>Function File: <em></em> <strong>scatter3</strong> <em>(&hellip;, <var>prop</var>, <var>val</var>)</em></dt>
<dt><a name="index-scatter3-6"></a>Function File: <em></em> <strong>scatter3</strong> <em>(<var>hax</var>, &hellip;)</em></dt>
<dt><a name="index-scatter3-7"></a>Function File: <em><var>h</var> =</em> <strong>scatter3</strong> <em>(&hellip;)</em></dt>
<dd><p>Draw a 3-D scatter plot.
</p>
<p>A marker is plotted at each point defined by the coordinates in the vectors
<var>x</var>, <var>y</var>, and <var>z</var>.
</p>
<p>The size of the markers is determined by <var>s</var>, which can be a scalar
or a vector of the same length as <var>x</var>, <var>y</var>, and <var>z</var>.  If <var>s</var>
is not given, or is an empty matrix, then a default value of 8 points is
used.
</p>
<p>The color of the markers is determined by <var>c</var>, which can be a string
defining a fixed color; a 3-element vector giving the red, green, and blue
components of the color; a vector of the same length as <var>x</var> that gives
a scaled index into the current colormap; or an Nx3 matrix defining
the RGB color of each marker individually.
</p>
<p>The marker to use can be changed with the <var>style</var> argument, that is a
string defining a marker in the same manner as the <code>plot</code> command.
If no marker is specified it defaults to <code>&quot;o&quot;</code> or circles.
If the argument <code>&quot;filled&quot;</code> is given then the markers are filled.
</p>
<p>Additional property/value pairs are passed directly to the underlying
patch object.
</p>
<p>If the first argument <var>hax</var> is an axes handle, then plot into this axis,
rather than the current axes returned by <code>gca</code>.
</p>
<p>The optional return value <var>h</var> is a graphics handle to the hggroup
object representing the points.
</p>
<div class="example">
<pre class="example">[x, y, z] = peaks (20);
scatter3 (x(:), y(:), z(:), [], z(:));
</pre></div>


<p><strong>See also:</strong> <a href="Two_002dDimensional-Plots.html#XREFscatter">scatter</a>, <a href="Graphics-Objects.html#XREFpatch">patch</a>, <a href="Two_002dDimensional-Plots.html#XREFplot">plot</a>.
</p></dd></dl>


<a name="XREFwaterfall"></a><dl>
<dt><a name="index-waterfall"></a>Function File: <em></em> <strong>waterfall</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>)</em></dt>
<dt><a name="index-waterfall-1"></a>Function File: <em></em> <strong>waterfall</strong> <em>(<var>z</var>)</em></dt>
<dt><a name="index-waterfall-2"></a>Function File: <em></em> <strong>waterfall</strong> <em>(&hellip;, <var>c</var>)</em></dt>
<dt><a name="index-waterfall-3"></a>Function File: <em></em> <strong>waterfall</strong> <em>(&hellip;, <var>prop</var>, <var>val</var>, &hellip;)</em></dt>
<dt><a name="index-waterfall-4"></a>Function File: <em></em> <strong>waterfall</strong> <em>(<var>hax</var>, &hellip;)</em></dt>
<dt><a name="index-waterfall-5"></a>Function File: <em><var>h</var> =</em> <strong>waterfall</strong> <em>(&hellip;)</em></dt>
<dd><p>Plot a 3-D waterfall plot.
</p>
<p>A waterfall plot is similar to a <code>meshz</code> plot except only
mesh lines for the rows of <var>z</var> (x-values) are shown.
</p>
<p>The wireframe mesh is plotted using rectangles.  The vertices of the
rectangles [<var>x</var>, <var>y</var>] are typically the output of <code>meshgrid</code>.
over a 2-D rectangular region in the x-y plane.  <var>z</var> determines the
height above the plane of each vertex.  If only a single <var>z</var> matrix is
given, then it is plotted over the meshgrid
<code><var>x</var> = 1:columns (<var>z</var>), <var>y</var> = 1:rows (<var>z</var>)</code>.
Thus, columns of <var>z</var> correspond to different <var>x</var> values and rows
of <var>z</var> correspond to different <var>y</var> values.
</p>
<p>The color of the mesh is computed by linearly scaling the <var>z</var> values
to fit the range of the current colormap.  Use <code>caxis</code> and/or
change the colormap to control the appearance.
</p>
<p>Optionally the color of the mesh can be specified independently of <var>z</var>
by supplying a color matrix, <var>c</var>.
</p>
<p>Any property/value pairs are passed directly to the underlying surface
object.
</p>
<p>If the first argument <var>hax</var> is an axes handle, then plot into this axis,
rather than the current axes returned by <code>gca</code>.
</p>
<p>The optional return value <var>h</var> is a graphics handle to the created
surface object.
</p>

<p><strong>See also:</strong> <a href="#XREFmeshz">meshz</a>, <a href="#XREFmesh">mesh</a>, <a href="#XREFmeshc">meshc</a>, <a href="Two_002dDimensional-Plots.html#XREFcontour">contour</a>, <a href="#XREFsurf">surf</a>, <a href="Graphics-Objects.html#XREFsurface">surface</a>, <a href="#XREFribbon">ribbon</a>, <a href="#XREFmeshgrid">meshgrid</a>, <a href="#XREFhidden">hidden</a>, <a href="#XREFshading">shading</a>, <a href="Representing-Images.html#XREFcolormap">colormap</a>, <a href="Axis-Configuration.html#XREFcaxis">caxis</a>.
</p></dd></dl>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="Aspect-Ratio.html#Aspect-Ratio" accesskey="1">Aspect Ratio</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="Three_002ddimensional-Function-Plotting.html#Three_002ddimensional-Function-Plotting" accesskey="2">Three-dimensional Function Plotting</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="Three_002ddimensional-Geometric-Shapes.html#Three_002ddimensional-Geometric-Shapes" accesskey="3">Three-dimensional Geometric Shapes</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<div class="header">
<p>
Next: <a href="Plot-Annotations.html#Plot-Annotations" accesskey="n" rel="next">Plot Annotations</a>, Previous: <a href="Two_002dDimensional-Plots.html#Two_002dDimensional-Plots" accesskey="p" rel="prev">Two-Dimensional Plots</a>, Up: <a href="High_002dLevel-Plotting.html#High_002dLevel-Plotting" accesskey="u" rel="up">High-Level Plotting</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
